---
layout: post
title: Help! My Selenium tests are flaky!
date: '2009-06-04T10:39:00.002-04:00'
author: Dawn
tags: 
modified_time: '2009-06-04T13:10:54.207-04:00'
blogger_id: tag:blogger.com,1999:blog-6005334108330583722.post-7993557448101933677
blogger_orig_url: http://confessionsofanagiletester.blogspot.com/2009/06/help-my-selenium-tests-are-flaky.html
---

In my development of Selenium tests, I have come to dread the oh-so-common "Permission denied" errors.  A quick scan of google search results indicates that there is likely some cross-domain issue, and a suggested workaround is using an experimental browser, like *iehta.  I generally use *iehta anyway, and still seem to have problems with the "Permission denied" error.<br /><br />In my most recent experience, testing against what seems to be an inconsistently slow and sometimes flaky web app, I have come to expect that "Permission denied" usually indicates that an element that I am trying to access is not yet accessible.  For my app, which is heavily AJAXed, "waitforpagetoload" doesn't cut it.  Since the AJAX scripts are still running, Selenium would wait until the end of time (or the timeout, whichever comes first) for the page to load and it would not.<br /><br />So, I found a few people who solved this problem by creating a function that would wait for a specific element to load.  I decided to go with it, and now my "WaitForElement" function is standard in my local Selenium Template for Visual Studio.<br /><br />This function looks like this (this is C# code):<br /><br /><span style="font-family:courier new;">private void WaitForElement(string elementName)<br />  {<br />     for (int second = 0; ; second++)<br />        {<br />           if (second >= 120) Assert.Fail("timeout");<br />           try </span><br /><span style="font-family:courier new;">              { </span><br /><span style="font-family:courier new;">                 if (selenium.IsElementPresent(elementName)) break; </span><br /><span style="font-family:courier new;">              }<br />           catch (Exception e) { }<br />           Thread.Sleep(1000);<br />        }<br />   }</span><br /><br />I call this function the first time I am going to take action after the web app has has to re-load or re-render elements.  I tend to pass it the element which I am wanting to interact with first. <br /><br />So in my test, the steps tend to look like this:<br /><span style="font-family:courier new;">   selenium.Click("btn1");</span><br /><span style="font-family:courier new;">   WaitForElement("txtBox1");</span><br /><span style="font-family:courier new;">   selenium.Type("txtBox1", "username");</span><br /><br />I have seen some other suggestions from people on stabilizing selenium tests, but would love to hear from anyone else who has worked out a way to make their selenium tests less fail-prone.